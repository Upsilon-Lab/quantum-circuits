# -*- coding: utf-8 -*-
"""DJ_Alg.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mwudRiOFv6UEKg5HGSDxp5LsK-PbXxat
"""

!pip install qiskit
import qiskit as q
from qiskit.visualization import plot_histogram, plot_bloch_multivector

# initialization
import numpy as np

# importing Qiskit
from qiskit import IBMQ, Aer
from qiskit.providers.ibmq import least_busy
from qiskit import QuantumCircuit, assemble, transpile

# import basic plot tools
from qiskit.visualization import plot_histogram

qbits = 3

const_oracle = QuantumCircuit(qbits+1)

output = np.random.randint(2)
if output == 1:
    const_oracle.x(qbits)

const_oracle.draw()

balanced_oracle = QuantumCircuit(qbits+1)

binary_str = 101

balanced_oracle = QuantumCircuit(qbits+1)
binary_str = "101"

# Place X-gates
for qubit in range(len(binary_str)):
    if binary_str[qubit] == '1':
        balanced_oracle.x(qubit)

# Use barrier as divider
balanced_oracle.barrier()

# Controlled-NOT gates
for qubit in range(qbits):
    balanced_oracle.cx(qubit, qbits)

balanced_oracle.barrier()

# Place X-gates
for qubit in range(len(binary_str)):
    if binary_str[qubit] == '1':
        balanced_oracle.x(qubit)

# Show oracle
balanced_oracle.draw()

dj_circuit = QuantumCircuit(qbits+1, qbits)

# Apply H-gates
for qubit in range(qbits):
    dj_circuit.h(qubit)

# Put qubit in state |->
dj_circuit.x(qbits)
dj_circuit.h(qbits)
dj_circuit.draw()

# Add/apply oracle to DJ algorithm
dj_circuit += balanced_oracle
dj_circuit.draw()

# Repeat H-gates
for qubit in range(qbits):
    dj_circuit.h(qubit)
dj_circuit.barrier()

# Measure
for i in range(qbits):
    dj_circuit.measure(i, i)

# Display circuit
dj_circuit.draw()

# use local simulator to visualize the output
aer_sim = Aer.get_backend('aer_simulator')
qobj = assemble(dj_circuit, aer_sim)
results = aer_sim.run(qobj).result()
answer = results.get_counts()

plot_histogram(answer)

